#' A Custom ggplot2 Theme for NMFprofileR Visuals
#'
#' This internal helper function provides a consistent and clean ggplot2 theme
#' for plots generated by the NMFprofileR package.
#'
#' @return A ggplot2 theme object.
#' @noRd
custom_theme <- function() {
  ggplot2::theme(
    legend.position = "right",
    panel.background = ggplot2::element_rect(fill = "#f2f2f2", colour = "#f2f2f2"),
    panel.grid.major = ggplot2::element_line(size = 0.5, linetype = 'solid', colour = "#dbe3db"),
    panel.grid.minor = ggplot2::element_line(size = 0.25, linetype = 'solid', colour = "#dbe3db"),
    axis.title = ggplot2::element_text(size = 14),
    axis.text = ggplot2::element_text(size = 12),
    panel.border = ggplot2::element_rect(colour = "black", fill = NA, size = 0.5)
  )
}


#' Generate All Plots for a Single NMF Rank
#'
#' This internal function creates a comprehensive suite of visualizations for the
#' results of a single NMF run (for a specific rank k). It saves all plots as
#' PDF files in a rank-specific directory.
#'
#' @param k The current rank (integer).
#' @param nmf_result The NMFfit object from the `NMF` package.
#' @param sample_assignments A data frame mapping samples to their dominant factor.
#' @param combined_gprofiler_df A data frame of all PER-FACTOR enrichment results.
#' @param combined_enrichment_results_df A data frame from the analysis of ALL basis genes.
#' @param expr_matrix The original, filtered expression matrix.
#' @param basis_genes A list of basis genes for each factor.
#' @param k_plots_dir The path to the output directory for this rank's plots.
#' @param file_prefix The base prefix for all output file names.
#' @param nrun The number of NMF runs performed.
#' @param top_n The number of top enriched terms to display in dot plots.
#' @param gost_objects_list
#' #' @importFrom tidyselect where
#'
#' @noRd
generate_rank_plots <- function(k, nmf_result, sample_assignments, combined_gprofiler_df,
                                combined_enrichment_results_df, expr_matrix, basis_genes,
                                k_plots_dir, file_prefix, nrun, top_n, gost_objects_list) {

  cli::cli_alert_info("Generating plots for k={k}...")

  # --- Create Annotation Objects for Heatmaps with a Robust Color Palette ---
  H <- NMF::coef(nmf_result)
  sample_annot_df <- data.frame(Factor = sample_assignments$Dominant_Factor)
  rownames(sample_annot_df) <- sample_assignments$SampleID

  # Define a base palette and extend it if k is large
  base_palette <- c("#008000", "#800080", "#ffcc00", "#d40000", "#d40055", "#0073c2")
  final_palette <- if (k <= length(base_palette)) {
    base_palette[1:k]
  } else {
    c(base_palette, grDevices::hcl.colors(k - length(base_palette), "viridis"))
  }
  factor_colors <- stats::setNames(final_palette, paste0("Factor_", 1:k))

  ha_col <- ComplexHeatmap::HeatmapAnnotation(
    df = sample_annot_df, col = list(Factor = factor_colors), which = "column",
    show_legend = TRUE, show_annotation_name = TRUE,
    annotation_name_gp = grid::gpar(fontsize = 8),
    annotation_legend_param = list(Factor = list(title = "NMF Factor"))
  )

  # --- Factor Summary Bar Plot ---
  factor_summary_df <- sample_assignments %>%
    dplyr::count(.data$Dominant_Factor, .drop = FALSE) %>%
    dplyr::mutate(Percent = (.data$n / sum(.data$n)) * 100)

  suppressWarnings({
    factor_summary_plot <- ggplot2::ggplot(factor_summary_df, ggplot2::aes(x = .data$Dominant_Factor, y = .data$Percent, fill = .data$Dominant_Factor)) +
      ggplot2::geom_col() +
      ggplot2::geom_text(data = . %>% dplyr::filter(.data$n > 0), ggplot2::aes(label = .data$n), vjust = -0.5) +
      ggplot2::labs(title = "NMF Factor Summary", subtitle = paste("k =", k), x = "NMF Factor", y = "Percent of Cohort") +
      ggplot2::theme_classic(base_size = 12) +
      ggplot2::scale_fill_manual(values = factor_colors, guide = "none", drop = FALSE) +
      custom_theme() +
      ggplot2::theme(legend.position = "none")

    ggplot2::ggsave(
      filename = file.path(k_plots_dir, paste0("02_Factor_Summary_Plot_Rank_k", k, ".pdf")),
      plot = factor_summary_plot, width = 6, height = 5, device = "pdf"
    )
  })
  # --- Enrichment Plots ---
  enrichment_plots_dir <- file.path(k_plots_dir, "Enrichment_Plots")
  dir.create(enrichment_plots_dir, showWarnings = FALSE, recursive = TRUE)


  # --- Manhattan plot section with extensive debugging ---

  # Step 1: filter out NULL elements
  valid_gost_results <- gost_objects_list[!sapply(gost_objects_list, is.null)]

  # Step 2: ensure deterministic names for the list elements
  orig_names <- names(valid_gost_results)

  # Create fallback names if necessary (use Factor_#_k# to be unambiguous)
  fallback_names <- paste0("Factor_", seq_along(valid_gost_results), "_k", k)
  if (is.null(orig_names) || any(is.na(orig_names) | orig_names == "")) {
    names(valid_gost_results) <- fallback_names
  } else {
    # keep original names but replace any empty with fallback
    new_names <- orig_names
    empty_idx <- which(is.na(new_names) | new_names == "")
    if (length(empty_idx) > 0) new_names[empty_idx] <- fallback_names[empty_idx]
    names(valid_gost_results) <- new_names
  }

  # Step 3: iterate over each gost object and generate a Manhattan plot if safe
  if (length(valid_gost_results) > 0) {
    cli::cli_alert_info("-> Generating enrichment Manhattan plot(s)...")

    for (nm in names(valid_gost_results)) {
      gost_obj <- valid_gost_results[[nm]]

      # Check for result presence and structure
      has_result <- is.list(gost_obj) && "result" %in% names(gost_obj)

      if (has_result) {
        res_df <- gost_obj$result
        if (is.data.frame(res_df)) {
          # Inspect query column if present
          if ("query" %in% colnames(res_df)) {
            qvals <- res_df$query
          }
        }
      }

      # Decide whether to plot
      can_plot <- FALSE
      reason_skip <- character(0)
      if (!is.list(gost_obj)) {
        reason_skip <- "gost_obj is not a list"
      } else if (!("result" %in% names(gost_obj))) {
        reason_skip <- "missing 'result' element"
      } else if (!is.data.frame(gost_obj$result)) {
        reason_skip <- "'result' is not a data.frame"
      } else if (nrow(gost_obj$result) == 0) {
        reason_skip <- "'result' has 0 rows"
      } else if (!("query" %in% colnames(gost_obj$result))) {
        # gostplot uses result$query for splitting/grouping; require it
        reason_skip <- "'result' lacks 'query' column"
      } else if (all(is.na(gost_obj$result$query))) {
        reason_skip <- "'result$query' is all NA"
      } else {
        can_plot <- TRUE
      }

      if (can_plot) {

      # Attempt to create and save the plot with robust error handling
      out_file <- file.path(enrichment_plots_dir, paste0("Enrichment_Manhattan_Plot_Rank_k", k, "_", nm, ".pdf"))

      tryCatch({
        # gostplot can be noisy; suppress messages/warnings but preserve errors
        p <- suppressMessages(suppressWarnings(gprofiler2::gostplot(gost_obj, interactive = FALSE)))

        # Try to save using publish_gostplot (preferred if available)
        tryCatch({
          suppressWarnings(suppressMessages(
            gprofiler2::publish_gostplot(p,
                                         highlight_terms = NULL,
                                         filename = out_file,
                                         width = 12, height = 7)
          ))
        }, error = function(e_pub) {
          # fallback: if p is a ggplot object, try ggsave
          if (inherits(p, "ggplot")) {
            suppressWarnings(ggplot2::ggsave(filename = out_file, plot = p, width = 10, height = 6, device = "pdf"))
          } else {
            stop("gostplot output not saveable by publish_gostplot or ggsave")
          }
        })

      }, error = function(e_plot) {
        cli::cli_alert_warning(paste0("Failed to generate Manhattan plot for ", nm, " (k=", k, "): ", conditionMessage(e_plot)))
        # continue to next factor without stopping the pipeline
      })

      }
    } # end for loop

  } else {
    cli::cli_alert_warning(paste0("No enrichment results available for Manhattan plots at k=", k))
  }

  # Quick guard
  if (is.null(combined_gprofiler_df) || nrow(combined_gprofiler_df) == 0) {
    cli::cli_alert_info("-> combined_gprofiler_df is empty; skipping per-factor dot plots.")
  } else {
    # Defensively find the correct column names for 'Factor' and 'source'
    col_lc <- tolower(colnames(combined_gprofiler_df))
    factor_col <- if ("factor" %in% col_lc) "Factor" else if ("query" %in% col_lc) "query" else NULL
    source_col <- if ("source" %in% col_lc) "source" else NULL

    if (is.null(factor_col) || is.null(source_col)) {
      cli::cli_alert_warning("-> Missing 'Factor'/'query' or 'source' column in enrichment data; skipping per-factor dot plots.")
    } else {
      # Prepare a clean data frame for plotting
      plot_df <- combined_gprofiler_df %>%
        # Ensure required columns exist and handle potential missing ones gracefully
        dplyr::mutate(
          .Factor = as.character(.data[[factor_col]]),
          .source = as.character(.data[[source_col]]),
          p_value = if ("p_value" %in% names(.)) .data$p_value else NA_real_,
          term_name = if ("term_name" %in% names(.)) .data$term_name else "Unknown",
          intersection_size = if ("intersection_size" %in% names(.)) .data$intersection_size else 1
        ) %>%
        # Filter for rows that have all necessary information for plotting
        dplyr::filter(
          !is.na(.data$.Factor) & nzchar(.data$.Factor) &
            !is.na(.data$.source) & nzchar(.data$.source) &
            !is.na(.data$p_value)
        )

      if (nrow(plot_df) > 0) {
        # Split the data frame into a list of data frames, one for each plot
        plot_groups <- split(plot_df, list(plot_df$.source, plot_df$.Factor), drop = TRUE)

        # Use lapply to iterate and create a plot for each group
        invisible(lapply(plot_groups, function(group_df) {
          tryCatch({
            src <- group_df$.source[1]
            factor_name <- group_df$.Factor[1]

            # Select top N terms by p-value for each group
            plot_data_enrich <- group_df %>%
              dplyr::arrange(.data$p_value) %>%
              dplyr::slice_head(n = top_n)

            plot_height <- 3 + (nrow(plot_data_enrich) * 0.3)

            enrich_plot <- ggplot2::ggplot(plot_data_enrich, ggplot2::aes(x = -log10(.data$p_value), y = forcats::fct_reorder(stringr::str_wrap(.data$term_name, 60), -log10(.data$p_value)))) +
              ggplot2::geom_segment(ggplot2::aes(x = 0, xend = -log10(.data$p_value), yend = forcats::fct_reorder(stringr::str_wrap(.data$term_name, 60), -log10(.data$p_value))), color = "gray") +
              ggplot2::geom_point(ggplot2::aes(size = .data$intersection_size), color = "steelblue") +
              ggplot2::labs(
                title = paste("Top Enriched Terms:", src),
                subtitle = paste("Cohort k =", k, "|", factor_name),
                x = "-Log10(Adjusted P-value)", y = NULL, size = "Gene Count"
              ) +
              ggplot2::theme_bw(base_size = 11) + custom_theme() + ggplot2::theme(axis.text.y = ggplot2::element_text(size = 9))

            # Create a file-safe name and save the plot
            safe_src_name <- gsub(":", "_", src)
            out_file <- file.path(enrichment_plots_dir, paste0("Enrichment_Dot_Plot_Rank_k", k, "_", factor_name, "_", safe_src_name, ".pdf"))
            ggplot2::ggsave(filename = out_file, plot = enrich_plot, width = 8, height = plot_height, device = "pdf", limitsize = FALSE)

          }, error = function(e) {
            cli::cli_alert_warning("-> Failed to generate a dot plot for group {.val {src}/{factor_name}}: {e$message}")
          })
        }))
      } else {
        cli::cli_alert_info("-> No valid enrichment results found to generate per-factor dot plots.")
      }
    }
  }

  # --- UMAP of Sample Coefficients ---
  H_matrix_t <- t(H)
  if (nrow(H_matrix_t) > 15) { # UMAP is more stable with >15 neighbors
    umap_res <- uwot::umap(H_matrix_t, n_neighbors = 15)
    umap_df <- as.data.frame(umap_res) %>%
      `colnames<-`(c("UMAP1", "UMAP2")) %>%
      dplyr::mutate(Dominant_Factor = sample_assignments$Dominant_Factor)

    suppressWarnings({
      umap_plot <- ggplot2::ggplot(umap_df, ggplot2::aes(x = .data$UMAP1, y = .data$UMAP2, color = .data$Dominant_Factor)) +
        ggplot2::geom_point(alpha = 0.8, size = 2) +
        ggplot2::scale_color_manual(values = factor_colors, drop = FALSE) +
        ggplot2::labs(title = "UMAP of NMF Sample Coefficients", subtitle = paste("k =", k), color = "NMF Factor") +
        ggplot2::theme_minimal() + custom_theme()

      ggplot2::ggsave(
        filename = file.path(k_plots_dir, paste0("05_UMAP_Plot_Rank_k", k, ".pdf")),
        plot = umap_plot, width = 7, height = 5.5, device = "pdf"
      )
    })
  }

  # --- Expression Heatmaps ---
  heatmap_plots_dir <- file.path(k_plots_dir, "Expression_Heatmaps")
  dir.create(heatmap_plots_dir, showWarnings = FALSE, recursive = TRUE)

  # --- Plot 1: Global Heatmap (all basis genes) ---
  genes_for_global_heatmap <- unique(unlist(basis_genes))
  if (length(genes_for_global_heatmap) > 1) {
    mat_plot <- expr_matrix[genes_for_global_heatmap, , drop = FALSE]
    # Scale data: log2 transform, then calculate row-wise Z-score
    mat_scaled <- t(scale(t(log2(mat_plot + 1))))
    mat_scaled[is.na(mat_scaled)] <- 0 # Handle cases with zero variance
    # Cap the Z-scores for better color mapping
    mat_scaled[mat_scaled > 2.5] <- 2.5
    mat_scaled[mat_scaled < -2.5] <- -2.5

    ht_global <- ComplexHeatmap::Heatmap(
      mat_scaled,
      name = "Row Z-Score",
      col = circlize::colorRamp2(c(-2.5, 0, 2.5), c("#3771c8", "white", "#ff9955")),
      top_annotation = ha_col,
      show_row_names = FALSE,
      show_column_names = FALSE,
      column_title = "All Basis Genes",
      # Split rows and columns by their predicted factor for a structured view
      row_split = NMF::predict(nmf_result, what = "features")[genes_for_global_heatmap],
      column_split = NMF::predict(nmf_result, what = "samples")
    )

    grDevices::pdf(file.path(heatmap_plots_dir, paste0("Expression_Heatmap_Global_Rank_k", k, ".pdf")), 8, 7)
    ComplexHeatmap::draw(ht_global)
    grDevices::dev.off()
  }

  # --- Plot 2: Individual Heatmap for Each Factor ---
  for (factor_idx in 1:k) {
    factor_name <- paste0("Factor_", factor_idx)
    factor_genes <- basis_genes[[factor_name]]

    # Only create a heatmap if there are at least 2 genes for this factor
    if (length(factor_genes) > 1) {
      mat_plot_factor <- expr_matrix[factor_genes, , drop = FALSE]
      mat_scaled_factor <- t(scale(t(log2(mat_plot_factor + 1))))
      mat_scaled_factor[is.na(mat_scaled_factor)] <- 0
      mat_scaled_factor[mat_scaled_factor > 2.5] <- 2.5
      mat_scaled_factor[mat_scaled_factor < -2.5] <- -2.5

      # Order the columns by this factor's coefficient values for clear visualization
      col_order <- order(H[factor_idx, ], decreasing = TRUE)

      ht_factor <- ComplexHeatmap::Heatmap(
        mat_scaled_factor[, col_order, drop = FALSE],
        name = "Row Z-Score",
        col = circlize::colorRamp2(c(-2.5, 0, 2.5), c("#3771c8", "white", "#ff9955")),
        top_annotation = ha_col,
        show_row_names = FALSE,
        show_column_names = FALSE,
        column_title = paste(factor_name, "Gene Signature")
      )

      # Adjust plot dimensions based on number of genes to show
      plot_height <- if (length(factor_genes) <= 50) 7 else 6
      plot_width <- 8

      grDevices::pdf(file.path(heatmap_plots_dir, paste0("Expression_Heatmap_Rank_k", k, "_", factor_name, ".pdf")), plot_width, plot_height)
      ComplexHeatmap::draw(ht_factor)
      grDevices::dev.off()
    }
  }

  # --- NMF Diagnostic Plots ---
  if (nrun > 1) {
    # Capture and save Consensus Map
    cm_plot <- capture_plot({
      NMF::consensusmap(nmf_result, main = paste("Consensus Map: k =", k))
    })

    pdf(file.path(k_plots_dir, paste0("01_ConsensusMap_Rank_k", k, ".pdf")), 8, 8)
    replayPlot(cm_plot)
    dev.off()
  } else {
    cli::cli_alert_warning("Skipping Consensus Map (requires nmf_nrun > 1).")
  }

  # Capture and save Basis Map
  bm_plot <- capture_plot({
    NMF::basismap(nmf_result)
  })
  pdf(file.path(k_plots_dir, paste0("03_BasisMap_Rank_k", k, ".pdf")), 7, 9)
  replayPlot(bm_plot)
  dev.off()

  # Capture and save Coefficient Map
  cf_plot <- capture_plot({
    NMF::coefmap(nmf_result)
  })
  pdf(file.path(k_plots_dir, paste0("04_CoefMap_Rank_k", k, ".pdf")), 10, 8)
  replayPlot(cf_plot)
  dev.off()

}


#' Generate All Global Summary Plots for a Multi-Rank NMF Analysis
#'
#' Creates summary visualizations to compare results across all tested ranks.
#'
#' @param rank_metrics A data frame of quality metrics from `nmfEstimateRank`.
#' @param consolidated_summary_df A data frame summarizing all factors across ranks.
#' @param nmf_rank Integer vector of ranks that were tested.
#' @param nrun Number of NMF runs performed.
#' @param dirs A named list of output directories.
#' @param file_prefix The base prefix for output file names.
#' @importFrom tidyselect where
#'
#' @noRd
generate_global_plots <- function(rank_metrics, consolidated_summary_df, nmf_rank, nrun, dirs, file_prefix) {

  cli::cli_h2("Generating final summary files and global plots...")

  # --- Plot 1: Consolidated Summary Heatmap ---
  if (nrow(consolidated_summary_df) > 0) {
    summary_matrix <- consolidated_summary_df %>%
      dplyr::mutate(ID = paste0("k", .data$Rank, "_", .data$Factor)) %>%
      dplyr::select(-"Rank", -"Factor") %>%
      tibble::column_to_rownames("ID") %>%
      dplyr::select(where(is.numeric)) %>%
      as.matrix()

    # Scale and handle NA/Inf issues
    summary_matrix_scaled <- scale(summary_matrix, center = TRUE, scale = TRUE)
    summary_matrix_scaled[!is.finite(summary_matrix_scaled)] <- 0 # Replace NaN/Inf with 0

    if (nrow(summary_matrix_scaled) > 1 && ncol(summary_matrix_scaled) > 1) {
      ht_summary <- ComplexHeatmap::Heatmap(
        summary_matrix_scaled, name = "Scaled Value\n(Column Z-Score)",
        column_title = "Factor Summary Metrics Across All Ranks",
        row_split = consolidated_summary_df$Rank, row_title = "Rank k=%s",
        cluster_rows = TRUE, cluster_columns = TRUE
      )
      cli::cli_alert_info("Generating {.path 04_Consolidated_Summary_Heatmap.pdf}")
      grDevices::pdf(file.path(dirs$plots, "04_Consolidated_Summary_Heatmap.pdf"), 10, 8)
      ComplexHeatmap::draw(ht_summary)
      grDevices::dev.off()
    }
  }

  # --- Global plots below are only meaningful if >1 rank was tested ---
  if (length(nmf_rank) > 1) {
    # --- Plot 2: Factor Correspondence Heatmap ---
    all_basis_matrices <- lapply(nmf_rank, function(k_val) {
      nmf_obj_path <- file.path(dirs$nmf_core, paste0("NMF_Result_Object_Rank_k", k_val, ".rds"))
      if (file.exists(nmf_obj_path)) {
        mat <- NMF::basis(readRDS(nmf_obj_path))
        colnames(mat) <- paste0("k", k_val, "_F", 1:k_val)
        return(mat)
      }
      return(NULL)
    })
    all_basis_matrices <- all_basis_matrices[!sapply(all_basis_matrices, is.null)]

    if (length(all_basis_matrices) > 1) {
      # Align genes before combining matrices
      all_genes <- unique(unlist(lapply(all_basis_matrices, rownames)))
      aligned_matrices <- lapply(all_basis_matrices, function(m) {
        m_aligned <- matrix(0, nrow = length(all_genes), ncol = ncol(m), dimnames = list(all_genes, colnames(m)))
        m_aligned[rownames(m), ] <- m
        m_aligned
      })
      combined_basis_matrix <- do.call(cbind, aligned_matrices)
      cor_matrix <- stats::cor(combined_basis_matrix)
      annot_df <- data.frame(Rank = stringr::str_extract(colnames(cor_matrix), "k[0-9]+"))
      rownames(annot_df) <- colnames(cor_matrix)

      cli::cli_alert_info("Generating {.path 03_Factor_Correspondence_Heatmap.pdf}")
      grDevices::pdf(file.path(dirs$plots, "03_Factor_Correspondence_Heatmap.pdf"), 10, 9)
      pheatmap::pheatmap(cor_matrix, annotation_col = annot_df, annotation_row = annot_df,
                         main = "Factor Correspondence Across Ranks")
      grDevices::dev.off()
    }

    # --- Plot 3: Combined Consensus Maps ---
    if (nrun > 1) {
      nmf_list <- lapply(nmf_rank, function(k_val) {
        nmf_obj_path <- file.path(dirs$nmf_core, paste0("NMF_Result_Object_Rank_k", k_val, ".rds"))
        if (file.exists(nmf_obj_path)) readRDS(nmf_obj_path) else NULL
      })
      nmf_list <- nmf_list[!sapply(nmf_list, is.null)]

      if (length(nmf_list) > 0) {
        cli::cli_alert_info("Generating {.path 01_Combined_Consensus_Map.pdf}")
        n_plots <- length(nmf_list)
        n_cols <- min(n_plots, 3)
        n_rows <- ceiling(n_plots / n_cols)
        pdf_width <- 5 * n_cols
        pdf_height <- 4 * n_rows

        # Capture the combined consensus map plot
        cm_plot <- capture_plot({
          NMF::consensusmap(nmf_list, labCol = NA, labRow = NA)
        })

        pdf(file.path(dirs$plots, "01_Combined_Consensus_Map.pdf"),width = pdf_width, height = pdf_height)
        replayPlot(cm_plot)
        dev.off()

      }
    }
  }
}
